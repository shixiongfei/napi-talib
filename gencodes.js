/*
 * gencodes.js
 *
 * Copyright (c) 2024-2025 Xiongfei Shi
 *
 * Author: Xiongfei Shi <xiongfei.shi(a)icloud.com>
 * License: Apache-2.0
 *
 * https://github.com/shixiongfei/napi-talib
 */

import fs from "node:fs";
import talib from "./index.js";

const inputFlagToName = (flag) => {
  switch (flag) {
    case "open":
      return "inOpen";

    case "high":
      return "inHigh";

    case "low":
      return "inLow";

    case "close":
      return "inClose";

    case "volume":
      return "inVolume";

    case "openinterest":
      return "inOpenInterest";

    case "timestamp":
      return "inTimestamp";
  }
};

const genFuncArgsTypes = (funcInfo) => {
  const inputs = funcInfo.inputs
    .map((input) => {
      switch (input.type) {
        case "price":
          return input.flags.map(
            (flag) => `${inputFlagToName(flag)}: number[]`
          );

        case "real":
        case "integer":
          return `${input.name}: number[]`;
      }
    })
    .flat(Infinity);

  const opts = funcInfo.optInputs.map((input) => {
    return `${input.name}?: number`;
  });

  opts.push("startIdx?: number");
  opts.push("endIdx?: number");

  return `${inputs.join(", ")}, opts?: {${opts.join("; ")}}`;
};

const genFuncReturnsTypes = (funcInfo) => {
  return funcInfo.outputs.length === 1
    ? "number[]"
    : `[${funcInfo.outputs.map(() => "number[]").join(", ")}]`;
};

const getFirstName = (funcInfo) => {
  const input = funcInfo.inputs[0];
  return input.type === "price" ? inputFlagToName(input.flags[0]) : input.name;
};

const genCallInputs = (funcInfo) => {
  const inputs = funcInfo.inputs
    .map((input) => {
      switch (input.type) {
        case "price":
          return input.flags.map((flag) => {
            const name = flag === "openinterest" ? "openInterest" : flag;
            return `${name}: ${inputFlagToName(flag)}`;
          });

        case "real":
        case "integer":
          return `${input.name}: ${input.name}`;
      }
    })
    .flat(Infinity);

  return `{${inputs.join(", ")}}`;
};

const genCallArgs = (funcInfo) => {
  const codes = [
    `name: "${funcInfo.name}"`,
    "startIdx: opts?.startIdx ?? 0",
    `endIdx: opts?.endIdx ?? ${getFirstName(funcInfo)}.length - 1`,
    `params: Object.assign(${genCallInputs(funcInfo)}, opts ?? {})`,
  ];

  return `{${codes.join(", ")}}`;
};

const genFuncReturns = (funcInfo) => {
  return funcInfo.outputs.length === 1
    ? `fillNaN(results.begIndex, ${funcInfo.outputs[0].name}!)`
    : `[${funcInfo.outputs
        .map((output) => `fillNaN(results.begIndex, ${output.name}!)`)
        .join(", ")}]`;
};

const genFuncBody = (funcInfo) => {
  const outputs = funcInfo.outputs.map((output) => output.name);
  const codes = [
    `const results = execute(${genCallArgs(funcInfo)});`,
    `const {${outputs.join(", ")}} = results.results;`,
    `return ${genFuncReturns(funcInfo)};`,
  ];
  return codes.join("\n");
};

const genAsyncFuncBody = (funcInfo) => {
  const outputs = funcInfo.outputs.map((output) => output.name);
  const returns = genFuncReturnsTypes(funcInfo);

  const codes = [
    `return new Promise<${returns}>((resolve, reject) => {`,
    `  execute(${genCallArgs(funcInfo)}, (error, results) => {`,
    "    if (error) { return reject(error); }",
    `    const {${outputs.join(", ")}} = results.results;`,
    `    resolve(${genFuncReturns(funcInfo)});`,
    "  });",
    "});",
  ];
  return codes.join("\n");
};

const genFuncCode = (funcInfo) => {
  const args = genFuncArgsTypes(funcInfo);
  const returns = genFuncReturnsTypes(funcInfo);

  const codes = [
    `export function ${funcInfo.name} (${args}): ${returns} {`,
    genFuncBody(funcInfo),
    "}",
  ];

  return codes.join("\n");
};

const genAsyncFuncCode = (funcInfo) => {
  const args = genFuncArgsTypes(funcInfo);
  const returns = genFuncReturnsTypes(funcInfo);

  const codes = [
    `export function ${funcInfo.name} (${args}): Promise<${returns}> {`,
    genAsyncFuncBody(funcInfo),
    "}",
  ];

  return codes.join("\n");
};

const genHeaderCode = () => {
  const codes = [
    "/* This file is automatically generated by gencodes.js */",
    "import { execute } from './index.js'",
    "const fillNaN = (count: number, array: number[]) =>",
    "  Array(count).fill(NaN).concat(array);",
  ];

  return codes.join("\n");
};

const genFuncsCodes = () => {
  const codes = [genHeaderCode()];

  talib.getFunctions().forEach((funcName) => {
    const funcInfo = talib.explain(funcName);
    codes.push(genFuncCode(funcInfo));
  });

  return codes.join("\n");
};

const genPromisesCodes = () => {
  const codes = [genHeaderCode()];

  talib.getFunctions().forEach((funcName) => {
    const funcInfo = talib.explain(funcName);
    codes.push(genAsyncFuncCode(funcInfo));
  });

  return codes.join("\n");
};

const genCodes = () => {
  fs.writeFileSync("functions.ts", genFuncsCodes());
  fs.writeFileSync("promises.ts", genPromisesCodes());
};

genCodes();
